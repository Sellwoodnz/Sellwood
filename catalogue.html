<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sellwood catalogue</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
      :root {
        --bg: #f7f8fa;
        --card-bg: #ffffff;
        --text: #000;
        --muted: #aaa;
        --accent: #dc2626;
        --border: #eee;
        --shadow: 0 10px 20px rgba(2, 8, 23, 0.06);
        --radius: 14px;
        --maxw: 1200px;
        --control-h: 46px;
        --pill-h: 26px;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      html { scrollbar-gutter: stable; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: var(--text);
        background: #fff;
      }

      .container { max-width: var(--maxw); margin: 0 auto; padding: 24px 16px 48px; }
      header { display: grid; gap: 10px; margin-bottom: 16px; }
      .title {
        font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        font-size: clamp(30px, 4vw, 34px);
        font-weight: 800;
        letter-spacing: -0.02em;
        text-align: center;
      }

      .toolbar {
        position: sticky;
        top: 0;
        z-index: 10;
        padding: 12px 0 20px;
        margin-left: 20px;
        margin-right: 20px;
      }
      .toolbar::after { content: none; display: none; }

      .toolbar .search-wrap {
        display: grid;
        grid-template-columns: 1fr auto auto;
        align-items: center;
        gap: 15px;
        padding-left: 0;
        padding-right: 0;
      }

      @media (max-width: 640px) {
        .toolbar .search-wrap {
          grid-template-columns: 1fr;
          gap: 15px;
          padding-left: 0;
          padding-right: 0;
        }
        .toolbar .sort-select, .toolbar .view-toggle { display: none !important; }
      }

      .search {
        display: flex;
        align-items: center;
        gap: 10px;
        background: var(--card-bg);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        box-shadow: var(--shadow);
        min-width: 0;
        min-height: var(--control-h);
      }
      .search input {
        width: 100%;
        border: none; outline: none; background: transparent;
        font-size: 16px; color: var(--text); flex: 1 1 auto; min-width: 0;
      }
      .search input::-webkit-search-cancel-button { -webkit-appearance: none; }
      .search .icon { width: 20px; height: 20px; color: var(--muted); flex: 0 0 auto; }
      .clear-x {
        appearance: none; border: none; background: transparent; color: var(--muted);
        width: 24px; height: 24px; border-radius: 50%; display: none; align-items: center; justify-content: center;
        cursor: pointer; flex: 0 0 auto;
      }
      .search .icon-search { display: inline-block; }
      .search .clear-x { display: none; }
      .search.has-value .icon-search { display: none; }
      .search.has-value .clear-x { display: inline-flex; }
      .search .count { margin-left: auto; color: var(--muted); font-size: 12px; white-space: nowrap; flex: 0 0 auto; }

      .sort-select {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0 12px;
        height: var(--control-h);
        background: #fff;
        color: var(--muted);
        box-shadow: var(--shadow);
        font-size: 16px;
        -webkit-appearance: none; -moz-appearance: none; appearance: none;
        background-image: none; text-align: center; text-align-last: center;
      }

      .view-toggle { display: inline-flex; gap: 6px; justify-self: end; }
      .view-btn {
        appearance: none; border: 1px solid var(--border); background: #fff; color: #0f172a;
        height: var(--control-h); padding: 0 12px; border-radius: 12px; box-shadow: var(--shadow);
        cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-size: 14px;
      }
      .view-btn[aria-pressed="true"] { background: #fee2e2; color: #b91c1c; border-color: #fecaca; box-shadow: 0 2px 6px rgba(220, 38, 38, 0.12); }
      .view-btn svg { width: 18px; height: 18px; }

      .catbar {
        display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
        margin: 10px 0 0 0;
        transition: opacity 0.3s ease-out, max-height 0.3s ease-out, margin-top 0.3s ease-out;
        max-height: 40px; opacity: 1; overflow: hidden;
      }
      .catbar.hidden { max-height: 0; opacity: 0; margin-top: 0; }
      .cat-chip {
        appearance: none; border: 1px solid #e2e8f0; background: #eee; color: #0f172a;
        font-size: 13px; line-height: 1; border-radius: 999px; padding: 6px 10px; cursor: pointer; user-select: none;
        transition: background .15s ease, color .15s ease, border-color .15s ease, box-shadow .15s ease;
      }
      .cat-chip:hover { background: #f1f5f9; }
      .cat-chip.active {
        background: #fee2e2; color: #b91c1c; border-color: #fecaca; box-shadow: 0 2px 6px rgba(220, 38, 38, 0.12);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 16px; margin-top: 16px;
      }
      .card {
        background: var(--card-bg); border: 2px solid var(--border); border-radius: var(--radius);
        box-shadow: var(--shadow); overflow: clip; display: flex; flex-direction: column;
        transition: box-shadow .18s ease;
      }
      .card:hover { box-shadow: var(--shadow); }

      .media {
        width: 100%; aspect-ratio: 4 / 3; background: #eee; overflow: hidden; position: relative;
        user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent;
      }
      .carousel {
        display: flex; width: 100%; height: 100%;
        transition: transform .3s ease; will-change: transform; cursor: pointer; -webkit-tap-highlight-color: transparent;
      }
      .slide { width: 100%; height: 100%; flex: 0 0 100%; position: relative; -webkit-tap-highlight-color: transparent; }
      .slide img {
        width: 100%; height: 100%; object-fit: cover; display: block; pointer-events: none;
        transition: opacity .2s ease;
      }
      .slide img[data-state="loading"] { opacity: 0; }

      .dots {
        position: absolute; left: 50%; bottom: 8px; transform: translateX(-50%);
        display: inline-flex; gap: 6px; z-index: 2; -webkit-tap-highlight-color: transparent;
      }
      .dot {
        width: 6px; height: 6px; border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.9); padding: 0; line-height: 0; cursor: pointer;
        box-shadow: var(--shadow); backdrop-filter: blur(2px); -webkit-tap-highlight-color: transparent;
      }
      .dot.active { border-color: var(--accent); background: var(--accent); box-shadow: 0 2px 6px rgba(220, 38, 38, 0.25); }

      .img-price {
        position: absolute; left: 10px; bottom: 10px;
        height: var(--pill-h); padding: 0 10px; border-radius: 999px; background: #dc2626; color: #fff;
        font-weight: 400; font-size: 12px; line-height: 1; display: inline-flex; align-items: center;
        box-shadow: var(--shadow); backdrop-filter: blur(2px); z-index: 1;
      }

      .img-ctas { position: absolute; right: 10px; bottom: 10px; display: inline-flex; gap: 8px; z-index: 1; -webkit-tap-highlight-color: transparent; }
      .img-cta {
        appearance: none; height: var(--pill-h); padding: 0 10px; border-radius: 5px; font-size: 12px; font-weight: 600;
        line-height: 1; display: inline-flex; align-items: center; border: none; background: rgba(255, 255, 255, 0.88);
        color: #000000; text-decoration: none; cursor: pointer; transition: transform .15s ease, background .15s ease;
        box-shadow: var(--shadow); backdrop-filter: blur(2px); -webkit-tap-highlight-color: transparent;
      }

      .nav-arrow {
        position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px;
        background: transparent; border: none; color: rgba(255, 255, 255, 0.95);
        font-size: 40px; line-height: 1; display: flex; align-items: center; justify-content: center;
        z-index: 2; cursor: pointer; user-select: none; text-shadow: 0 1px 2px rgba(0,0,0,.35);
        transition: opacity .2s ease, transform .15s ease;
      }
      .nav-prev { left: 6px; }
      .nav-next { right: 6px; }
      .nav-arrow:active { transform: translateY(-50%) scale(0.98); }
      .nav-arrow:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: 6px; }
      @media (hover: hover) { .nav-arrow { opacity: 0; } .media:hover .nav-arrow { opacity: 1; } }

      .content { display: flex; flex-direction: column; gap: 8px; padding: 14px; }
      .title-row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; }
      .title-row .name { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .name { font-weight: 700; font-size: 16px; line-height: 1.25; }
      .code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        color: #000000; background: #eee; border: 1px solid #e2e8f0; padding: 2px 8px;
        width: fit-content; border-radius: 999px; font-size: 12px; flex: 0 0 auto;
      }

      .models { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; margin-bottom: 2px; }
      .model-tag { font-size: 12px; color: #b91c1c; background: #fee2e2; border: 1px solid #fecaca; border-radius: 999px; padding: 2px 8px; width: fit-content; }

      .attrs { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; margin-bottom: 2px; }
      .attr-pill {
        font-size: 10px; color: #000000; background: #eee; border: 1px solid #e2e8f0; border-radius: 999px; padding: 2px 8px; width: fit-content;
      }
      .material-pill { background: #ddd; }
      .finish-pill { background: #eee; }
      .manufacturer-pill { background: #eef6ff; border: 1px solid #cfe8ff; color: #0b5394; }

      .desc { color: #334155; font-size: 14px; line-height: 1.4;
        display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }

      .empty { display: none; text-align: center; color: var(--muted); font-size: 14px; margin: 24px 0; }
      .empty.active { display: block; }

      .modal {
        position: fixed; inset: 0; z-index: 1000; display: grid; place-items: center;
        background: rgba(2, 8, 23, 0.55); padding: 12px; opacity: 0; visibility: hidden;
        transition: opacity .18s ease, visibility .18s ease;
      }
      .modal.open { opacity: 1; visibility: visible; }
      .modal .panel {
        box-sizing: border-box; width: min(960px, calc(100vw - 24px)); height: min(92vh, calc(100vh - 24px));
        background: #fff; border: 1px solid var(--border); border-radius: 12px; box-shadow: var(--shadow);
        overflow: hidden; display: grid;
      }
      .modal .panel iframe { width: 100%; height: 100%; border: 0; display: block; }
      @media (max-width: 640px) {
        .modal { padding: 10px; }
        .modal .panel { width: calc(100vw - 20px); height: calc(100vh - 20px); border-radius: 10px; }
        .catbar { overflow-x: auto; max-height: 100px; }
      }
      body.modal-open { overflow: hidden; }

      /* List view */
      body[data-view="list"] .grid { display: flex; flex-direction: column; gap: 12px; }
      body[data-view="list"] .card { flex-direction: row; align-items: stretch; }
      body[data-view="list"] .media {
        flex: 0 0 180px; width: 180px; aspect-ratio: 4 / 3; border-right: 1px solid var(--border);
      }
      @media (min-width: 1100px) {
        body[data-view="list"] .media { flex-basis: 220px; width: 220px; }
      }
      body[data-view="list"] .content { padding: 12px 14px; gap: 8px; justify-content: center; }
      body[data-view="list"] .desc { display: block; -webkit-line-clamp: initial; -webkit-box-orient: initial; overflow: visible; }
      body[data-view="list"] .title-row { display: none; }
      body[data-view="list"] .dots { display: none; }
      body[data-view="list"] .name-row { display: flex; align-items: center; gap: 12px; }
      body[data-view="list"] .content>.models { margin: 0; }
      body[data-view="list"] .content>.attrs { margin: 0; }

      /* Back to top button */
      .back-to-top {
        position: fixed;
        right: clamp(12px, 2.5vw, 20px);
        bottom: clamp(12px, 2.5vh, 20px);
        width: 42px; height: 42px; border-radius: 999px; border: 1px solid var(--border);
        background: #fff; color: #0f172a; box-shadow: var(--shadow);
        display: inline-flex; align-items: center; justify-content: center; cursor: pointer;
        opacity: 0; transform: translateY(8px) scale(0.96); visibility: hidden;
        transition: opacity .2s ease, transform .2s ease, visibility .2s ease;
        z-index: 990; pointer-events: none; touch-action: manipulation;
      }
      .back-to-top.visible { opacity: 1; transform: translateY(0) scale(1); visibility: visible; pointer-events: auto; }
      .back-to-top:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
      .back-to-top svg { width: 18px; height: 18px; }
      @media (hover: hover) { .back-to-top:hover { transform: translateY(-1px) scale(1.02); } }
    </style>
  </head>
  <body data-view="tiles">
    <div class="container">
      <header>
        <div class="title">Sellwood Catalog</div>
      </header>
      <div class="toolbar">
        <div class="search-wrap">
          <label class="search" for="search" id="searchLabel">
            <button class="clear-x" id="clearX" type="button" aria-label="Clear search" title="Clear search">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" />
              </svg>
            </button>
            <svg class="icon icon-search" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M21 21l-4.35-4.35M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15z" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" />
            </svg>
            <input id="search" type="search" placeholder="Search" autocomplete="off" aria-label="Search parts" />
            <span id="count" class="count" aria-live="polite">0 of 0</span>
          </label>
          <select id="sort" class="sort-select" aria-label="Sort">
            <option value="relevance">Sort</option>
            <option value="name-asc">A–Z</option>
            <option value="name-desc">Z–A</option>
            <option value="price-asc">$ Low</option>
            <option value="price-desc">$ High</option>
          </select>
          <div class="view-toggle" role="group" aria-label="Change layout">
            <button id="viewTilesBtn" class="view-btn" type="button" aria-pressed="true" title="Tiles view">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <rect x="4" y="4" width="7" height="7" stroke="currentColor" stroke-width="1.8" rx="1.5" />
                <rect x="13" y="4" width="7" height="7" stroke="currentColor" stroke-width="1.8" rx="1.5" />
                <rect x="4" y="13" width="7" height="7" stroke="currentColor" stroke-width="1.8" rx="1.5" />
                <rect x="13" y="13" width="7" height="7" stroke="currentColor" stroke-width="1.8" rx="1.5" />
              </svg> Tiles </button>
            <button id="viewListBtn" class="view-btn" type="button" aria-pressed="false" title="List view">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <rect x="4" y="6" width="16" height="2" fill="currentColor" />
                <rect x="4" y="11" width="16" height="2" fill="currentColor" />
                <rect x="4" y="16" width="16" height="2" fill="currentColor" />
              </svg> List </button>
          </div>
        </div>
        <div id="catBar" class="catbar" role="group" aria-label="Filter by category"></div>
      </div>
      <div id="grid" class="grid" aria-live="polite"></div>
      <div id="empty" class="empty" aria-live="polite"></div>
    </div>

    <div id="pdfModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="panel">
        <iframe id="pdfFrame" title="PDF"></iframe>
      </div>
    </div>

    <button id="backTopBtn" class="back-to-top" type="button" aria-label="Back to top" title="Back to top">
      <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M7 14l5-5 5 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </button>

    <script>
      // Configuration
      const CSV_URL = 'catalogue.csv';
      const currency = 'NZD';
      const IMAGE_DIR = 'images/catalogue';
      const IMAGE_DEFAULT_EXTS = ['jpg', 'png']; // try JPG first (often smaller), then PNG
      const FILE_DIR = IMAGE_DIR;
      const FILE_DEFAULT_EXT = 'pdf';
      const MAX_IMAGES = 5;

      const CATEGORY_PRIORITY = ['Attic Ladder', 'Roof Access', 'Roof Hatch', 'Natural Lighting', 'Fixings'];
      const CAT_PARAM = 'cat';
      const VIEW_PARAM = 'view';
      const VIEW_TILES = 'tiles';
      const VIEW_LIST = 'list';

      // File existence cache (PDF only) to avoid broken links without heavy network
      const EXISTS_CACHE_KEY = 'catalog.exists.v1';
      const EXISTS_CACHE_TTL = 1000 * 60 * 60 * 24 * 7; // 7 days
      let existsCache;
      try {
        existsCache = JSON.parse(localStorage.getItem(EXISTS_CACHE_KEY)) || { images: {}, file: {} };
      } catch { existsCache = { images: {}, file: {} }; }
      function getCached(type, key) {
        const entry = (existsCache[type] || {})[key];
        if (!entry) return null;
        if ((Date.now() - (entry.ts || 0)) > EXISTS_CACHE_TTL) return null;
        return entry.value;
      }
      function setCached(type, key, value) {
        if (!existsCache[type]) existsCache[type] = {};
        existsCache[type][key] = { ts: Date.now(), value };
        try { localStorage.setItem(EXISTS_CACHE_KEY, JSON.stringify(existsCache)); } catch {}
      }

      // DOM refs
      const grid = document.getElementById('grid');
      const countEl = document.getElementById('count');
      const emptyEl = document.getElementById('empty');
      const searchInput = document.getElementById('search');
      const clearX = document.getElementById('clearX');
      const sortSelect = document.getElementById('sort');
      const searchLabel = document.getElementById('searchLabel');
      const pdfModal = document.getElementById('pdfModal');
      const pdfFrame = document.getElementById('pdfFrame');
      const catBar = document.getElementById('catBar');
      const backTopBtn = document.getElementById('backTopBtn');
      const viewTilesBtn = document.getElementById('viewTilesBtn');
      const viewListBtn = document.getElementById('viewListBtn');

      const fmtPrice = new Intl.NumberFormat('en-NZ', { style: 'currency', currency, currencyDisplay: 'narrowSymbol' });

      // State
      let PARTS = [];
      const SCORES = new Map();
      let lastFocused = null;
      let selectedCategory = '';
      let ALL_CATEGORIES = [];
      let viewMode = VIEW_TILES;

      // Image loading helpers (no HEAD): decode off-DOM, then swap into card
      let imageObserver = null;
      const loadingSet = new Set(); // keys by slug to avoid duplicate loads

      function debounce(fn, wait = 180) {
        let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), wait); };
      }
      function norm(s) {
        return String(s || '').toLowerCase().normalize('NFKD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[_/\\-]+/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      }
      function slugify(s) { return norm(s).replace(/\s+/g, '-'); }
      function splitList(s) { if (!s) return []; return String(s).split(/[;]+|,(?!\s)/g).map(v => v.trim()).filter(Boolean); }

      function tryLoadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.decoding = 'async';
          img.onload = () => resolve(url);
          img.onerror = img.onabort = reject;
          img.src = url;
        });
      }

      async function findFirstImageUrl(slug) {
        for (const ext of IMAGE_DEFAULT_EXTS) {
          const url = `${IMAGE_DIR.replace(/\/?$/, '/')}${slug}.${ext}`;
          try {
            const okUrl = await tryLoadImage(url);
            return okUrl;
          } catch {}
        }
        return null;
      }

      // Optionally discover more images after the first (non-blocking)
      async function findAdditionalImageUrls(slug, startIndex = 2, max = MAX_IMAGES) {
        const urls = [];
        for (let j = startIndex; j <= max; j++) {
          const suffix = j > 1 ? `-${j}` : '';
          let found = null;
          for (const ext of IMAGE_DEFAULT_EXTS) {
            const url = `${IMAGE_DIR.replace(/\/?$/, '/')}${slug}${suffix}.${ext}`;
            try {
              const okUrl = await tryLoadImage(url);
              found = okUrl;
              break;
            } catch {}
          }
          if (found) urls.push(found);
          else break; // stop at first gap to avoid many 404 attempts
        }
        return urls;
      }

      function buildMediaHTML(p, resolved) {
        const slidesHTML = resolved.map((src, i) => `
          <div class="slide">
            <img src="${src}" alt="${(p.name||'Part')} image ${i+1}" decoding="async" />
          </div>`).join('');
        const dotsHTML = resolved.length > 1 ? `
          <div class="dots">${resolved.map((_,i)=>`
            <button class="dot ${i===0?'active':''}" type="button" aria-label="Go to image ${i+1}" data-i="${i}"></button>`).join('')}
          </div>` : '';
        const arrowsHTML = resolved.length > 1 ? `
          <button class="nav-arrow nav-prev" type="button" aria-label="Previous image" title="Previous">‹</button>
          <button class="nav-arrow nav-next" type="button" aria-label="Next image" title="Next">›</button>` : '';

        const linkCTA = (p.link && p.link.url) ? `
          <a class="img-cta" href="${p.link.url}" target="_blank" rel="noopener" aria-label="${p.link.label} for ${p.name}">${p.link.label}</a>` : '';
        const fileCTA = p.file ? `
          <button class="img-cta pdf-cta" type="button" data-file="${p.file}" data-title="${p.name}">File</button>` : '';
        const ctaGroup = (linkCTA || fileCTA) ? `
          <div class="img-ctas">${linkCTA}${fileCTA}</div>` : '';

        return `
          <div class="carousel" role="group" aria-label="Images for ${p.name}">
            ${slidesHTML}
          </div>
          ${p.price>0 ? `<div class="img-price" title="Price">${fmtPrice.format(p.price)}</div>` : ''}
          ${ctaGroup}
          ${dotsHTML}
          ${arrowsHTML}
        `;
      }

      async function loadCardImagesForPart(card, p, priority = false) {
        const key = p.slug || p.code || p.name;
        if (!key || loadingSet.has(key) || (p.images && p.images.length)) return;
        loadingSet.add(key);

        try {
          const first = await findFirstImageUrl(p.slug);
          if (first) {
            // ensure the card is still in DOM
            if (!card.isConnected) return;
            const media = card.querySelector('.media');
            if (media) {
              p.images = [first];
              media.innerHTML = buildMediaHTML(p, p.images);
              setupCarousel(media);
            }

            // discover extra images (non-blocking)
            findAdditionalImageUrls(p.slug, 2, MAX_IMAGES).then(more => {
              if (!more.length) return;
              p.images = p.images.concat(more);
              if (!card.isConnected) return;
              const media2 = card.querySelector('.media');
              if (media2) {
                media2.innerHTML = buildMediaHTML(p, p.images);
                setupCarousel(media2);
              }
            });
          }
        } finally {
          loadingSet.delete(key);
        }
      }

      function ensureImageObserver() {
        if (imageObserver) return imageObserver;
        imageObserver = new IntersectionObserver((entries) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              const card = entry.target;
              const slug = card.getAttribute('data-slug');
              const code = card.getAttribute('data-code');
              const p = PARTS.find(x => (x.slug === slug) || (code && x.code === code));
              if (p) loadCardImagesForPart(card, p);
              imageObserver.unobserve(card);
            }
          }
        }, { root: null, rootMargin: '200px 0px 200px 0px', threshold: 0.01 });
        return imageObserver;
      }

      function observeCardForImages(card, p) {
        card.setAttribute('data-slug', p.slug);
        if (p.code) card.setAttribute('data-code', p.code);
        ensureImageObserver().observe(card);
      }

      // Optionally prime top-of-list images to appear ASAP
      function primeAboveTheFold(count = 10) {
        const cards = Array.from(grid.querySelectorAll('.card')).slice(0, count);
        cards.forEach(card => {
          const slug = card.getAttribute('data-slug');
          const code = card.getAttribute('data-code');
          const p = PARTS.find(x => (x.slug === slug) || (code && x.code === code));
          if (p) loadCardImagesForPart(card, p, true);
        });
      }

      async function checkFileExists(slug) {
        if (!slug) return null;
        const cached = getCached('file', slug);
        if (cached !== null) return cached;
        const v = `${FILE_DIR.replace(/\/?$/,'/')}${slug}.${FILE_DEFAULT_EXT}`;
        try {
          const res = await fetch(v, { method: 'HEAD', cache: 'force-cache' });
          const ok = res.ok ? v : null;
          setCached('file', slug, ok);
          return ok;
        } catch { return null; }
      }

      function parseCSV(text) {
        if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
        const rows = [];
        let i = 0, f = '', row = [], q = false;
        const pushF = () => { row.push(f); f = ''; };
        const pushR = () => { rows.push(row); row = []; };
        while (i < text.length) {
          const c = text[i];
          if (q) {
            if (c === '"') { if (text[i+1] === '"') { f += '"'; i++; } else { q = false; } }
            else { f += c; }
          } else {
            if (c === '"') q = true;
            else if (c === ',') pushF();
            else if (c === '\n') { pushF(); pushR(); }
            else if (c === '\r') { /* ignore */ }
            else { f += c; }
          }
          i++;
        }
        if (f.length > 0 || row.length) { pushF(); pushR(); }
        const cleaned = rows.filter((r, idx) => {
          if (idx === 0) return true;
          const nonEmpty = r.filter(v => String(v).trim() !== '');
          if (nonEmpty.length === 0) return false;
          const first = String(nonEmpty[0]).trim();
          if (nonEmpty.length === 1 && (/^(#|;|\/\/)/.test(first))) return false;
          return true;
        });
        if (!cleaned.length) return [];
        const header = cleaned[0].map(h => norm(h).replace(/\s+/g, ''));
        return cleaned.slice(1).map(r => {
          const o = {}; for (let j = 0; j < header.length; j++) o[header[j]] = r[j] ?? ''; return o;
        });
      }

      function pick(rec, names) {
        for (const n of names) {
          if (rec[n] != null && String(rec[n]).trim() !== '') return rec[n];
        }
        return '';
      }

      function parseLink(raw) {
        const s = String(raw || '').trim();
        if (!s) return null;
        const idx = s.indexOf(';');
        let label = '', url = '';
        if (idx === -1) {
          if (/^https?:\/\//i.test(s)) { label = 'Link'; url = s; }
          else return null;
        } else {
          label = s.slice(0, idx).trim();
          url = s.slice(idx + 1).trim();
          if (!url) return null;
          if (!label) label = 'Link';
        }
        return { label, url };
      }

      function recordsToParts(records) {
        return records.map((rec, i) => {
          const name = pick(rec, ['name']);
          const nameSlug = slugify(name);
          const possibleImageNames = [];
          for (let j = 1; j <= MAX_IMAGES; j++) {
            const suffix = j > 1 ? `-${j}` : '';
            possibleImageNames.push(`${nameSlug}${suffix}`);
          }
          const code = pick(rec, ['code']);
          const description = pick(rec, ['description']);
          const price = parseFloat(pick(rec, ['price'])) || 0;
          const models = splitList(pick(rec, ['model', 'models']));
          const categories = splitList(pick(rec, ['category', 'categories', 'catagory']));
          const materials = splitList(pick(rec, ['material']));
          const finishes = splitList(pick(rec, ['finish', 'finiah']));
          const keywords = splitList(pick(rec, ['keywords']));
          const manufacturer = pick(rec, ['manufacturer', 'brand', 'make']);
          const linkRaw = pick(rec, ['link']);
          const link = parseLink(linkRaw);
          return {
            slug: nameSlug,
            name, code, description, price,
            possibleImageNames,
            models, categories, materials, finishes,
            keywords, manufacturer,
            link,
            images: [], // will be filled when loaded
            file: null,
            order: i
          };
        });
      }

      function render(list) {
        grid.innerHTML = '';
        const q = searchInput.value.trim();
        if (!list.length) {
          let msg = '';
          if (PARTS.length === 0) msg = 'No parts available.';
          else if (q || selectedCategory) {
            const catTxt = selectedCategory ? ` in "${selectedCategory}"` : '';
            const qTxt = q ? ` for "${q}"` : '';
            msg = `No parts found${catTxt}${qTxt}.`;
          }
          emptyEl.textContent = msg;
          if (msg) emptyEl.classList.add('active'); else emptyEl.classList.remove('active');
          updateCountText(0);
          return;
        } else {
          emptyEl.classList.remove('active');
        }

        list.forEach(p => {
          const card = document.createElement('article');
          card.className = 'card';
          card.setAttribute('data-code', p.code || '');
          card.setAttribute('data-slug', p.slug);

          const hasModels = Array.isArray(p.models) && p.models.length > 0;
          const modelsHTML = hasModels ? p.models.map(m => `<span class="model-tag">${m}</span>`).join('') : '';

          const hasManufacturer = !!(p.manufacturer && String(p.manufacturer).trim());
          const manufacturerHTML = hasManufacturer ? `<span class="attr-pill manufacturer-pill" title="Manufacturer">${p.manufacturer}</span>` : '';

          const hasMaterials = Array.isArray(p.materials) && p.materials.length > 0;
          const hasFinishes = Array.isArray(p.finishes) && p.finishes.length > 0;
          const materialsHTML = hasMaterials ? p.materials.map(mat => `<span class="attr-pill material-pill" title="Material">${mat}</span>`).join('') : '';
          const finishesHTML = hasFinishes ? p.finishes.map(fin => `<span class="attr-pill finish-pill" title="Finish">${fin}</span>`).join('') : '';

          const attrsHTML = (hasManufacturer || hasMaterials || hasFinishes)
            ? `<div class="attrs" aria-label="Manufacturer, material and finish">${manufacturerHTML}${materialsHTML}${finishesHTML}</div>`
            : '';

          const rawImages = p.images || [];
          const placeholder = `https://placehold.jp/48/eee/666/600x400.png?text=${encodeURIComponent(p.name || 'Part')}`;
          const resolved = rawImages.length ? rawImages : [placeholder];

          const slidesHTML = resolved.map((src, i) => `
            <div class="slide">
              <img src="${src}" alt="${(p.name||'Part')} image ${i+1}" loading="lazy" decoding="async" />
            </div>`).join('');
          const dotsHTML = resolved.length > 1 ? `
            <div class="dots">${resolved.map((_,i)=>`
              <button class="dot ${i===0?'active':''}" type="button" aria-label="Go to image ${i+1}" data-i="${i}"></button>`).join('')}
            </div>` : '';
          const arrowsHTML = resolved.length > 1 ? `
            <button class="nav-arrow nav-prev" type="button" aria-label="Previous image" title="Previous">‹</button>
            <button class="nav-arrow nav-next" type="button" aria-label="Next image" title="Next">›</button>` : '';

          const linkCTA = (p.link && p.link.url)
            ? `<a class="img-cta" href="${p.link.url}" target="_blank" rel="noopener" aria-label="${p.link.label} for ${p.name}">${p.link.label}</a>`
            : '';
          const fileCTA = p.file
            ? `<button class="img-cta pdf-cta" type="button" data-file="${p.file}" data-title="${p.name}">File</button>`
            : '';
          const ctaGroup = (linkCTA || fileCTA) ? `<div class="img-ctas">${linkCTA}${fileCTA}</div>` : '';

          // Build card
          if (viewMode === VIEW_LIST) {
            card.innerHTML = `
              <div class="media" data-index="0">
                <div class="carousel" role="group" aria-label="Images for ${p.name}">
                  ${slidesHTML}
                </div>
                ${p.price>0 ? `<div class="img-price" title="Price">${fmtPrice.format(p.price)}</div>` : ''}
                ${ctaGroup}
                ${dotsHTML}
                ${arrowsHTML}
              </div>
              <div class="content">
                <div class="name-row">
                  <div class="name">${p.name}</div>
                  ${p.code ? `<div class="code">${p.code}</div>` : ''}
                </div>
                ${hasModels ? `<div class="models" aria-label="Compatible models">${modelsHTML}</div>` : ''}
                ${attrsHTML}
                <div class="desc">${p.description}</div>
              </div>
            `;
          } else {
            card.innerHTML = `
              <div class="media" data-index="0">
                <div class="carousel" role="group" aria-label="Images for ${p.name}">
                  ${slidesHTML}
                </div>
                ${p.price>0 ? `<div class="img-price" title="Price">${fmtPrice.format(p.price)}</div>` : ''}
                ${ctaGroup}
                ${dotsHTML}
                ${arrowsHTML}
              </div>
              <div class="content">
                <div class="title-row">
                  <div class="name">${p.name}</div>
                  ${p.code ? `<div class="code">${p.code}</div>` : ''}
                </div>
                ${hasModels ? `<div class="models" aria-label="Compatible models">${modelsHTML}</div>` : ''}
                ${attrsHTML}
                <div class="desc">${p.description}</div>
              </div>
            `;
          }

          setupCarousel(card.querySelector('.media'));
          grid.appendChild(card);

          // Start image loading for this card when it comes into view
          observeCardForImages(card, p);
        });

        // Give above-the-fold cards a head start
        primeAboveTheFold(10);

        updateCountText(list.length);
      }

      // Carousel
      function setupCarousel(mediaEl) {
        const track = mediaEl.querySelector('.carousel');
        if (!track) return;
        const slides = track.children;
        const dots = mediaEl.querySelectorAll('.dot');
        const total = slides.length;
        if (total <= 1) return;

        const prevBtn = mediaEl.querySelector('.nav-prev');
        const nextBtn = mediaEl.querySelector('.nav-next');
        let idx = 0, startX = 0, startY = 0;

        function go(i) {
          idx = (i + total) % total;
          track.style.transform = `translateX(-${idx * 100}%)`;
          dots.forEach((d, j) => d.classList.toggle('active', j === idx));
          mediaEl.dataset.index = idx;
        }

        mediaEl.addEventListener('click', (e) => {
          if (e.target.closest('.img-cta') || e.target.closest('.dots') || e.target.closest('.nav-arrow')) return;
          go(idx + 1);
        });
        if (prevBtn) prevBtn.addEventListener('click', (e) => { e.stopPropagation(); go(idx - 1); });
        if (nextBtn) nextBtn.addEventListener('click', (e) => { e.stopPropagation(); go(idx + 1); });

        mediaEl.addEventListener('touchstart', (e) => {
          const t = e.touches[0]; startX = t.clientX; startY = t.clientY;
        }, { passive: true });
        mediaEl.addEventListener('touchend', (e) => {
          const t = e.changedTouches[0]; const dx = t.clientX - startX; const dy = t.clientY - startY;
          if (Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)) { if (dx < 0) go(idx + 1); else go(idx - 1); }
        }, { passive: true });
      }

      // Relevance scoring
      const WEIGHTS = {
        name: 3,
        code: 3,
        models: 2,
        materials: 2,
        finishes: 1,
        categories: 2,
        keywords: 1,
        description: 1,
        manufacturer: 2
      };

      function partMatchesCategory(p, cat) {
        if (!cat) return true;
        const cats = (p.categories || []).map(norm);
        return cats.includes(norm(cat));
      }

      function filterParts(query) {
        const q = norm(query);
        if (!q) {
          SCORES.clear();
          return PARTS.filter(p => partMatchesCategory(p, selectedCategory));
        }
        const tokens = q.split(' ');
        SCORES.clear();
        return PARTS.filter(p => {
          if (!partMatchesCategory(p, selectedCategory)) return false;
          const f = {
            name: norm(p.name),
            code: norm(p.code),
            description: norm(p.description),
            manufacturer: norm(p.manufacturer),
            categories: (p.categories || []).map(norm),
            models: (p.models || []).map(norm),
            keywords: (p.keywords || []).map(norm),
            materials: (p.materials || []).map(norm),
            finishes: (p.finishes || []).map(norm)
          };
          let score = 0;
          const pass = tokens.every(t => {
            let hit = false;
            for (const key of ['name', 'code', 'description', 'manufacturer']) {
              const val = f[key];
              if (val && val.includes(t)) {
                hit = true;
                score += WEIGHTS[key] + ((key === 'name' || key === 'code') && val.startsWith(t) ? 1 : 0);
              }
            }
            for (const key of ['models', 'keywords', 'categories', 'materials', 'finishes']) {
              const arr = f[key];
              if (arr?.some(v => v.includes(t))) { hit = true; score += WEIGHTS[key]; }
            }
            return hit;
          });
          if (pass) SCORES.set(p.code, score);
          return pass;
        });
      }

      function sortParts(list, mode) {
        const arr = list.slice();
        switch (mode) {
          case 'csv': return arr.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
          case 'price-asc': return arr.sort((a, b) => a.price - b.price || a.name.localeCompare(b.name));
          case 'price-desc': return arr.sort((a, b) => b.price - a.price || a.name.localeCompare(b.name));
          case 'name-asc': return arr.sort((a, b) => a.name.localeCompare(b.name));
          case 'name-desc': return arr.sort((a, b) => b.name.localeCompare(a.name));
          case 'relevance':
          default:
            if (SCORES.size === 0) return arr.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
            return arr.sort((a, b) => {
              const sa = SCORES.get(a.code) || 0, sb = SCORES.get(b.code) || 0;
              return sb - sa || (a.order ?? 0) - (b.order ?? 0);
            });
        }
      }

      // URL sync
      function updateUrl(q, s, cat, view) {
        const params = new URLSearchParams(location.search);
        if (q) params.set('q', q); else params.delete('q');
        if (s && s !== 'relevance') params.set('sort', s); else params.delete('sort');
        if (cat) params.set(CAT_PARAM, cat); else params.delete(CAT_PARAM);
        if (view && view !== VIEW_TILES) params.set(VIEW_PARAM, view); else params.delete(VIEW_PARAM);
        const qs = params.toString();
        history.replaceState(null, '', qs ? `${location.pathname}?${qs}` : location.pathname);
      }

      function setClearXVisible() {
        const has = searchInput.value.trim().length > 0;
        if (has) clearX.classList.add('visible'); else clearX.classList.remove('visible');
        searchLabel.classList.toggle('has-value', has);
      }

      function buildCategoryBar() {
        const set = new Set();
        PARTS.forEach(p => (p.categories || []).forEach(c => { if (c && c.trim()) set.add(c.trim()); }));
        const allCats = Array.from(set);
        const lowerPriority = CATEGORY_PRIORITY.map(norm);
        const pri = CATEGORY_PRIORITY.filter(c => allCats.some(x => norm(x) === norm(c)));
        const rest = allCats.filter(c => !lowerPriority.includes(norm(c))).sort((a, b) => a.localeCompare(b));
        ALL_CATEGORIES = [...pri, ...rest];

        catBar.innerHTML = '';
        const allChip = chipEl('All', selectedCategory === '' ? true : false, () => { selectedCategory = ''; update(); updateCatChipActive(); });
        catBar.appendChild(allChip);

        ALL_CATEGORIES.forEach(c => {
          const active = norm(c) === norm(selectedCategory);
          const el = chipEl(c, active, () => {
            selectedCategory = (norm(selectedCategory) === norm(c)) ? '' : c;
            update();
            updateCatChipActive();
          });
          catBar.appendChild(el);
        });
      }

      function chipEl(label, active = false, onClick) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'cat-chip' + (active ? ' active' : '');
        btn.textContent = label;
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        btn.addEventListener('click', onClick);
        return btn;
      }

      function updateCatChipActive() {
        const chips = catBar.querySelectorAll('.cat-chip');
        chips.forEach(ch => {
          const isAll = ch.textContent === 'All';
          const isActive = isAll ? selectedCategory === '' : norm(ch.textContent) === norm(selectedCategory);
          ch.classList.toggle('active', isActive);
          ch.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        updateUrl(searchInput.value, sortSelect.value, selectedCategory || '', viewMode);
      }

      function withPdfFit(url) {
        const [base, hash = ''] = url.split('#');
        const params = new URLSearchParams(hash);
        if (!params.has('page')) params.set('page', '1');
        if (!params.has('view')) params.set('view', 'Fit');
        if (!params.has('zoom')) {
          const ua = navigator.userAgent;
          const isChrome = /Chrome\/|Chromium\/|CriOS\//.test(ua) && !/Edg\//.test(ua) && !/OPR\//.test(ua);
          params.set('zoom', isChrome ? 'page-width' : 'page-fit');
        }
        const h = params.toString();
        return base + (h ? '#' + h : '');
      }

      function isMobile() {
        return window.matchMedia('(max-width: 640px)').matches || /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent);
      }

      function applyViewToDOM() {
        document.body.dataset.view = viewMode;
        const isTiles = viewMode === VIEW_TILES;
        viewTilesBtn.setAttribute('aria-pressed', isTiles ? 'true' : 'false');
        viewListBtn.setAttribute('aria-pressed', isTiles ? 'false' : 'true');
      }

      function setView(mode, opts = {}) {
        if (mode !== VIEW_TILES && mode !== VIEW_LIST) mode = VIEW_TILES;
        viewMode = mode;
        localStorage.setItem('catalogView', viewMode);
        applyViewToDOM();
        updateUrl(searchInput.value, sortSelect.value, selectedCategory || '', viewMode);
        if (!opts.noUpdate) update();
      }

      // X of X only
      function updateCountText(listLen) {
        const total = PARTS.length;
        if (selectedCategory) {
          const inCat = PARTS.filter(p => partMatchesCategory(p, selectedCategory)).length;
          countEl.textContent = `${listLen} of ${inCat}`;
        } else {
          countEl.textContent = `${listLen} of ${total}`;
        }
      }

      // Central update
      function update() {
        const q = searchInput.value;
        const s = sortSelect.value;
        const filtered = filterParts(q);
        const sorted = sortParts(filtered, s);
        render(sorted);
        updateUrl(q, s, selectedCategory || '', viewMode);
      }
      const debouncedUpdate = debounce(update, 150);

      // Events
      searchInput.addEventListener('input', () => { setClearXVisible(); debouncedUpdate(); });
      sortSelect.addEventListener('change', update);
      clearX.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        searchInput.value = ''; setClearXVisible(); update(); searchInput.blur();
      });

      viewTilesBtn.addEventListener('click', () => setView(VIEW_TILES));
      viewListBtn.addEventListener('click', () => setView(VIEW_LIST));

      grid.addEventListener('click', (e) => {
        const btn = e.target.closest('.pdf-cta');
        if (!btn) return;
        const url = btn.getAttribute('data-file');
        const finalUrl = withPdfFit(url);
        if (isMobile()) { window.location.assign(finalUrl); return; }
        openPdfModal(finalUrl);
      });

      function openPdfModal(url) {
        lastFocused = document.activeElement;
        pdfFrame.src = url;
        pdfModal.classList.add('open');
        document.body.classList.add('modal-open');
        document.addEventListener('keydown', onModalKeydown);
        pdfModal.addEventListener('click', onModalBackdrop);
      }
      function closePdfModal() {
        pdfModal.classList.remove('open');
        document.body.classList.remove('modal-open');
        pdfFrame.src = 'about:blank';
        document.removeEventListener('keydown', onModalKeydown);
        pdfModal.removeEventListener('click', onModalBackdrop);
        if (lastFocused && typeof lastFocused.focus === 'function') lastFocused.focus();
      }
      function onModalKeydown(e) { if (e.key === 'Escape') closePdfModal(); }
      function onModalBackdrop(e) {
        const panel = pdfModal.querySelector('.panel');
        if (!panel.contains(e.target)) closePdfModal();
      }

      // Hide category bar when not at top and toggle back-to-top
      let ticking = false;
      function onScrollRAF() {
        const y = window.scrollY || document.documentElement.scrollTop;
        catBar.classList.toggle('hidden', y > 0);
        backTopBtn.classList.toggle('visible', y > 300);
        ticking = false;
      }
      window.addEventListener('scroll', () => {
        if (!ticking) { requestAnimationFrame(onScrollRAF); ticking = true; }
      }, { passive: true });

      backTopBtn.addEventListener('click', () => {
        const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReduced) window.scrollTo(0, 0);
        else window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      // Init
      (async function init() {
        const params = new URLSearchParams(location.search);
        const q = params.get('q') || '';
        const s = params.get('sort') || 'relevance';
        const cat = params.get(CAT_PARAM) || '';

        const urlView = params.get(VIEW_PARAM);
        const savedView = localStorage.getItem('catalogView');
        const initialView =
          (urlView === VIEW_LIST || urlView === VIEW_TILES) ? urlView :
          (savedView === VIEW_LIST || savedView === VIEW_TILES) ? savedView :
          VIEW_TILES;
        setView(initialView, { noUpdate: true });

        searchInput.value = q;
        sortSelect.value = s;
        setClearXVisible();
        selectedCategory = cat;

        PARTS = await loadCSV(CSV_URL);

        // Light check for PDF availability (cached), done in background
        hydrateFiles(4);

        buildCategoryBar();
        update(); // render quickly with placeholders
      })();

      function hydrateFiles(concurrency = 4) {
        let i = 0;
        const workers = Array.from({ length: concurrency }, () => (async () => {
          while (true) {
            const idx = i++;
            if (idx >= PARTS.length) return;
            const p = PARTS[idx];
            p.file = await checkFileExists(p.slug);
          }
        })());
        Promise.all(workers).then(() => {
          // Update visible cards to show File CTAs if they became available
          update();
        });
      }

      async function loadCSV(url) {
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const text = await res.text();
          const records = parseCSV(text);
          return recordsToParts(records);
        } catch (err) {
          console.error('Failed to load CSV:', err);
          return [];
        }
      }

      function enforceMobileTiles() {
        const small = window.matchMedia('(max-width: 640px)').matches;
        if (small && viewMode !== 'tiles') setView('tiles');
      }
      window.addEventListener('resize', enforceMobileTiles, { passive: true });
      enforceMobileTiles();
    </script>
  </body>
</html>